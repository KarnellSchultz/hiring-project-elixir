diff --git a/lib/parser.ex b/lib/parser.ex
index cf22cb1..f4a7a25 100644
--- a/lib/parser.ex
+++ b/lib/parser.ex
@@ -35,8 +35,71 @@ defmodule Parser do
   #
 
   @doc """
-  Parses the raw consumption data in consumption_data to internal data format
+  Parses the consumption data in consumption_data to internal data format
   """
+
+  def getPeriods(timeSeries) do
+    get_in(timeSeries, ["Period"])
+    |> Enum.map(fn period ->
+      %{
+        interval_start: get_in(period, ["timeInterval", "start"]),
+        interval_end: get_in(period, ["timeInterval", "end"]),
+        points: get_in(period, ["Point"])
+      }
+    end)
+  end
+
+  def formatData(pointQuantity, metering_point_id, interval_start, interinterval_end) do
+    %{
+      metering_point_id: metering_point_id,
+      interval_start: interval_start,
+      interval_end: interinterval_end,
+      quantity: String.to_float(pointQuantity)
+    }
+  end
+
+  def getTimeIntervals(dateTime, time) do
+    hourInSeconds = 3600
+    offset = time * hourInSeconds
+    {:ok, initDateTime, 0} = DateTime.from_iso8601(dateTime)
+    startDateTime = DateTime.add(initDateTime, offset, :second)
+    endDateTime = DateTime.add(startDateTime, hourInSeconds, :second)
+
+    %{
+      interval_start: DateTime.to_iso8601(startDateTime),
+      interval_end: DateTime.to_iso8601(endDateTime)
+    }
+  end
+
+  def getTimeSeries(consumption_data) do
+    List.first(consumption_data["result"])
+    |> Map.get("MyEnergyData_MarketDocument")
+    |> Map.get("TimeSeries")
+    |> List.first()
+  end
+
   def parse(consumption_data) do
+    timeSeries = getTimeSeries(consumption_data)
+    metering_point_id = get_in(timeSeries, ["MarketEvaluationPoint", "mRID", "name"])
+    periods = getPeriods(timeSeries)
+
+    Enum.map(periods, fn period ->
+      get_in(period, [:points])
+      |> Enum.map(fn point ->
+        intervals =
+          getTimeIntervals(
+            get_in(period, [:interval_start]),
+            String.to_integer(get_in(point, ["position"]))
+          )
+
+        formatData(
+          Map.get(point, "out_Quantity.quantity"),
+          metering_point_id,
+          intervals[:interval_start],
+          intervals[:interval_end]
+        )
+      end)
+    end)
+    |> List.flatten()
   end
 end
diff --git a/test/parser_test.exs b/test/parser_test.exs
index 949230b..f414ca4 100644
--- a/test/parser_test.exs
+++ b/test/parser_test.exs
@@ -6,7 +6,57 @@ defmodule ParserTest do
   # YOUR TEST(S) BELOW THIS POINT
   #
 
-  test "sample test" do
-    assert true
+  test "find out if my thing works" do
+    assert Parser.getTimeIntervals("2021-12-31T23:00:00Z", 1) == %{
+             interval_end: "2022-01-01T01:00:00Z",
+             interval_start: "2022-01-01T00:00:00Z"
+           }
   end
+
+  test "parser returns the correct range of periods" do
+    assert Parser.getPeriods(%{
+             "MarketEvaluationPoint" => %{
+               "mRID" => %{"codingScheme" => "A10", "name" => "927613927390263674"}
+             },
+             "Period" => [
+               %{
+                 "Point" => [
+                   %{
+                     "out_Quantity.quality" => "A04",
+                     "out_Quantity.quantity" => "0.1",
+                     "position" => "1"
+                   }
+                 ],
+                 "resolution" => "PT1H",
+                 "timeInterval" => %{
+                   "end" => "2022-01-01T23:00:00Z",
+                   "start" => "2021-12-31T23:00:00Z"
+                 }
+               }
+             ],
+             "businessType" => "A04",
+             "curveType" => "A01",
+             "measurement_Unit.name" => "KWH",
+             "metering_point_id" => "927613927390263674"
+           }) == [
+             %{
+               interval_end: "2022-01-01T23:00:00Z",
+               interval_start: "2021-12-31T23:00:00Z",
+               points: [
+                 %{
+                   "out_Quantity.quality" => "A04",
+                   "out_Quantity.quantity" => "0.1",
+                   "position" => "1"
+                 }
+               ]
+             }
+           ]
+  end
+
+test "make sure the parser returns the correct keys" do
+  first = List.first(Parser.run())
+  assert Map.has_key?(first, :interval_start) && Map.has_key?(first, :interval_end) &&
+    Map.has_key?(first, :metering_point_id) && Map.has_key?(first, :quantity)
+end
+
 end
